<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            
            body {
                background-color: grey;
            }
            code {
                background-color: orange;
                color: darkblue;
                white-space: pre;
                font-family: fantasy;
            }
            h2 {
                color: darkblue;
            }
            
        </style>
        <script>
            
        </script>
    </head>
    <body>
            <h2>[146]-LRU-Cache-Hard</h2><p>[146] LRU Cache  </p>

<p>https://leetcode.com/problems/lru-cache/description/</p>

<ul>
<li>algorithms</li>
<li>Hard (20.30%)</li>
<li>Total Accepted:    180.4K</li>
<li>Total Submissions: 888.5K</li>
<li>Testcase Example:  '["LRUCache","put","put","get","put","get","put","get","get","get"]\n[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]'</li>
</ul>

<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>

<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>

<p>Follow up:
Could you do both operations in O(1) time complexity?</p>

<p>Example:</p>

<p>LRUCache cache = new LRUCache( 2 /* capacity */ );</p>

<p>cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4</p>

        <script>
            
        </script>
    </body>
</html>